// Zak Sakata
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "sem.h"

int* buffer = NULL;
int in, out = 0;

int BUFFER_SIZE;
int NUM_PRODUCERS;
int NUM_CONSUMERS;
int NUM_TIMES_TO_RUN;

Sem* full;
Sem* empty;
void producer(int threadID);
void consumer(int threadID);

int main() {
  RunQ = InitQueue(); // init queue in threads.h
  scanf("%d, %d, %d, %d", &BUFFER_SIZE, &NUM_PRODUCERS, &NUM_CONSUMERS, &NUM_TIMES_TO_RUN);
  
  buffer = (int*) malloc(BUFFER_SIZE * sizeof(int));
  full = InitSem(0); // tracks if buffer is full (for consumer)
  empty = InitSem(BUFFER_SIZE); // tracks if buffer is empty (for producer)

  for (int i = 0; i < NUM_PRODUCERS + NUM_CONSUMERS; i++) {
    int threadID;
    scanf("%d", &threadID);
    void* function = threadID > 0 ? producer : consumer;
    start_thread(function, threadID);
  }
  run();

  return 0;
}

void producer(int threadID) {
  for (int i = 1; i <= NUM_TIMES_TO_RUN; i++) {
    P(empty);

    if (!buffer[in]) {
      printf("\nProducer %d is producing item number %d\n", threadID, i);
      buffer[in] = threadID;
    }
    in = ++in % BUFFER_SIZE;
    // PrintQueue(RunQ);
    
    V(full);
    yield();
  }
}

void consumer(int threadID) {
  for (int i = 1; i <= NUM_TIMES_TO_RUN; i++) {
    P(full);
    
    if (buffer[out]) {
      printf("\nConsumer %d is consuming item generated by Producer %d\n", -threadID, buffer[out]);
      buffer[out] = 0; // reset buffer at out since item was consumed
    }
    out = ++out % BUFFER_SIZE;
    // PrintQueue(RunQ);
    
    V(empty);
    yield();
  }
}
